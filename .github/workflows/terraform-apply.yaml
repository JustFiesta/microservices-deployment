name: 'Terraform Apply'

on:
  issue_comment:
    types: [created]

env:
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCESS_KEY_ID : ${{ secrets.AWS_ACCESS_KEY_ID  }}
  AWS_SECRET_ACCESS_KEY : ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  
  TF_VERSION: '1.13.1'
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
  
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  detect-apply-environments:
    name: 'Detect Apply Target Environments'
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request && (contains(github.event.comment.body, '@bot apply') || contains(github.event.comment.body, '@bot reapply'))
    outputs:
      environments: ${{ steps.detect.outputs.environments }}
      action-type: ${{ steps.detect.outputs.action-type }}
      should-run: ${{ steps.detect.outputs.should-run }}
    
    steps:
    - name: Checkout to get available environments
      uses: actions/checkout@v4
      
    - name: Detect target environments
      id: detect
      uses: actions/github-script@v7
      with:
        github-token: ${{ env.GH_TOKEN }}
        script: |
          // Check permissions first
          const { data: collaborator } = await github.rest.repos.getCollaboratorPermissionLevel({
            owner: context.repo.owner,
            repo: context.repo.repo,
            username: context.actor
          });
          
          const hasPermission = ['admin', 'write'].includes(collaborator.permission);
          
          if (!hasPermission) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '‚ùå You do not have permission to run terraform apply.'
            });
            core.setOutput('should-run', 'false');
            return;
          }
          
          // Get available environments
          const { execSync } = require('child_process');
          const availableEnvs = execSync('find terraform -maxdepth 1 -type d ! -path terraform | sed "s|terraform/||" | sort', { encoding: 'utf8' }).trim().split('\n').filter(env => env);
          
          console.log('Available environments:', availableEnvs);
          
          // Parse comment to extract environment and action type
          const comment = context.payload.comment.body;
          let actionType = 'apply';
          let targetEnvs = [];
          
          if (comment.includes('@bot reapply')) {
            actionType = 'reapply';
          }
          
          // Check for specific environment
          const envMatch = comment.match(/env=(\w+)/);
          if (envMatch && availableEnvs.includes(envMatch[1])) {
            targetEnvs = [envMatch[1]];
          } else if (!envMatch) {
            // No specific environment - use all available
            targetEnvs = availableEnvs;
          } else {
            // Invalid environment specified
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå Environment "${envMatch[1]}" not found. Available environments: ${availableEnvs.join(', ')}`
            });
            core.setOutput('should-run', 'false');
            return;
          }
          
          // Convert to matrix format
          const matrixEnvs = targetEnvs.map(env => `terraform/${env}`);
          
          core.setOutput('should-run', 'true');
          core.setOutput('environments', JSON.stringify(matrixEnvs));
          core.setOutput('action-type', actionType);
          
          console.log('Target environments:', matrixEnvs);
          console.log('Action type:', actionType);
          
          // React to comment
          await github.rest.reactions.createForIssueComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.payload.comment.id,
            content: 'rocket'
          });

  terraform-apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    needs: detect-apply-environments
    if: needs.detect-apply-environments.outputs.should-run == 'true'
    
    permissions:
      contents: read
      pull-requests: write
      issues: write

    strategy:
      matrix:
        env_dir: ${{ fromJson(needs.detect-apply-environments.outputs.environments) }}

    env:
      WORKING_DIR: ${{ matrix.env_dir }}
      ACTION_TYPE: ${{ needs.detect-apply-environments.outputs.action-type }}
      
    steps:
    - name: Get PR details
      id: pr
      uses: actions/github-script@v7
      with:
        github-token: ${{ env.GH_TOKEN }}
        script: |
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          core.setOutput('ref', pr.head.sha);
          core.setOutput('branch', pr.head.ref);

    - name: Checkout PR branch
      uses: actions/checkout@v4
      with:
        ref: ${{ steps.pr.outputs.ref }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      id: init
      working-directory: ${{ github.workspace }}/${{ env.WORKING_DIR }}
      run: |
        terraform init \
          -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Download Plan (for apply)
      if: env.ACTION_TYPE == 'apply'
      uses: actions/download-artifact@v4
      with:
        name: tfplan-${{ matrix.env_dir }}-${{ steps.pr.outputs.ref }}
        path: ${{ env.WORKING_DIR }}
      continue-on-error: true

    - name: Terraform Plan (for reapply or missing plan)
      id: plan
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        ENV_NAME=$(basename ${{ env.WORKING_DIR }})
        
        if [ "${{ env.ACTION_TYPE }}" == "reapply" ] || [ ! -f "tfplan" ]; then
          echo "Creating new plan..."
          terraform plan -no-color -out=tfplan \
            -var="environment=${ENV_NAME}" 2>&1 | tee plan_output.txt
        else
          echo "Using existing plan..."
        fi
      continue-on-error: true

    - name: Terraform Apply
      id: apply
      working-directory: ${{ env.WORKING_DIR }}
      run: |
        if [ -f "tfplan" ]; then
          terraform apply -no-color -auto-approve tfplan 2>&1 | tee apply_output.txt
        else
          echo "‚ùå No plan file available for apply" | tee apply_output.txt
          exit 1
        fi
      continue-on-error: true

    - name: Comment PR with Apply Results
      uses: actions/github-script@v7
      with:
        github-token: ${{ env.GH_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          const workingDir = '${{ env.WORKING_DIR }}';
          const envName = path.basename(workingDir);
          const actionType = '${{ env.ACTION_TYPE }}';
          
          let applyOutput = '';
          let planOutput = '';
          
          try {
            applyOutput = fs.readFileSync(`${workingDir}/apply_output.txt`, 'utf8');
          } catch (error) {
            applyOutput = 'No apply output found.';
          }
          
          // Include plan output for reapply
          if (actionType === 'reapply') {
            try {
              planOutput = fs.readFileSync(`${workingDir}/plan_output.txt`, 'utf8');
            } catch (error) {
              planOutput = 'No plan output found.';
            }
          }
          
          const maxLength = 30000; // Smaller limit to fit both plan and apply
          const truncatedApplyOutput = applyOutput.substring(0, maxLength);
          const wasTruncatedApply = applyOutput.length > maxLength;
          
          const actionEmoji = actionType === 'reapply' ? 'üîÑ' : 'üöÄ';
          const actionText = actionType === 'reapply' ? 'Reapply' : 'Apply';
          const statusEmoji = '${{ steps.apply.outcome }}' === 'success' ? '‚úÖ' : '‚ùå';
          
          let output = `### ${actionEmoji} Terraform ${actionText} Results - Environment: **${envName}**
          
          #### Initialization: ${{ steps.init.outcome == 'success' && '‚úÖ' || '‚ùå' }}`;
          
          if (actionType === 'reapply') {
            output += `
          #### Re-planning: ${{ steps.plan.outcome == 'success' && '‚úÖ' || '‚ùå' }}`;
          }
          
          output += `
          #### Apply: ${statusEmoji}`;
          
          // Add plan output for reapply
          if (actionType === 'reapply' && planOutput) {
            const truncatedPlanOutput = planOutput.substring(0, maxLength);
            const wasTruncatedPlan = planOutput.length > maxLength;
            
            output += `
          
          <details><summary>Show Plan Output (Reapply)</summary>
          
          \`\`\`terraform
          ${truncatedPlanOutput}
          \`\`\`
          
          ${wasTruncatedPlan ? '\n‚ö†Ô∏è *Plan output was truncated due to length limits*' : ''}
          
          </details>`;
          }
          
          output += `
          
          <details><summary>Show Apply Output</summary>
          
          \`\`\`terraform
          ${truncatedApplyOutput}
          \`\`\`
          
          ${wasTruncatedApply ? '\n‚ö†Ô∏è *Apply output was truncated due to length limits*' : ''}
          
          </details>
          
          **üë§ Applied by:** @${{ github.actor }}
          **üåø Branch:** ${{ steps.pr.outputs.branch }}
          **‚è∞ Time:** ${new Date().toISOString()}`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: output
          });

    - name: Apply Status
      if: steps.apply.outcome == 'failure'
      run: |
        echo "Terraform apply failed for environment $(basename ${{ env.WORKING_DIR }})"
        exit 1